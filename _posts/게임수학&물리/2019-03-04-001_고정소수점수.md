---

title: "001_소수"
date: 2019-03-04 13:44:00 -0400
categories: "게임수학&물리"
comments: true

---

## 소수

**소수(Decimal)**는 각각의 자리에 놓인 숫자와 소수점을 통해 나타낸 실수

소수점 왼쪽에 놓인 숫자들은 실수의 정수 부분, 소수점 오른쪽에 놓인 숫자들은 실수의 소수 부분을 나타낸다.



소수를 표현하는 방법에는 **고정 소수점** 방식과 **부동 소수점 **방식이 있다.



## 고정소수점

**고정소수점**은 소수점을 사용하여 고정된 자리수의 소수를 나타내는 것

소수점 위치를 고정시킨 수 표현 방식, 소수점이 항상 같은 위치에 있다.



예를 들어 4바이트 수일 때 1바이트 = 8비트 이므로 32비트 수가 된다.

이 수를 비트로 나타냈을 때 위쪽 16비트를 정수 부분, 아래쪽 16비트를 소수 부분으로 생각할 수 있다.

아래는 1을 나타내는 소수를 4바이트 수로 나타낸 것이다.

```
00000000 00000000 00000000 00000001		00000000 00000000 00000000 00000000
정수 부분								 소수 부분
```

위와 같이 비트로 구성한 수를 0x10000(65536)으로 나누면 원래 수를 알 수 있다.



고정소수점수는 특정한 '형'을 가지지 않고, 평소에 사용하는 자료형(정수)을 사용해서 고정소수점수를 표현한다.



### 고정소수점수의 연산

고정소수점수끼리는 더하거나 뺄 때 그대로 계산하는 특징이 있다.

```
0x00438000 = 정수 부분 : 0x0043(67), 소수 부분 : 0x8000(0.5) -> 67.5
0x00126000 = 정수 부분 : 0x0012(18), 소수 부분 : 0x6000(0.375) -> 18.375

덧셈 : 0x0056e000
뺄셈 : 0x00312000
```

단, 곱하기나 나누기는 위와 같은 방식으로 계산할 수 없다.

67.5에 1.0을 곱하고 나누면 67.5로 바뀐 것이 없어야 하나, 아래의 결과를 보면 다르다는 걸 알 수 있다.

```
0x00438000 = 정수 부분 : 0x0043(67), 소수 부분 : 0x8000(0.5) -> 67.5
0x00010000 = 정수 부분 : 0x0001(1), 소수 부분 : 0x0000(0.0) -> 1.0

곱하기 : 0x80000000
나누기 : 0x00000043
```

이는 고정소수점수에 특정한 형이 있지 않고 일반적인 정수로 계산하기 때문에

67.5 * 1.0은 4바이트 수에서 (67.5 * 65536) * (1.0 * 65536) 이 되어서 매우 큰 수가 된다고 예측 가능하다.

따라서 고정소수점수를 곱하거나 나눌 땐 다른 방식을 사용해야한다.



### 고정소수점수의 형식

위의 예제에서는 정수 부분, 소수 부분을 각각 16비트씩 사용하였지만,

고정소수점수에서는 정수와 소수에 몇 비트를 할당하지 자유롭게 설정이 가능하다.

예를들어 4바이트 수에서 정수 부분을 8비트로, 소수 부분을 24비트로 사용하면 

(unsigned라고 가정했을 때) 정수 부분은 8비트인 0 ~ 255의 범위를 소수 부분은 24비트인  0 ~ 16777215을 나타낼 수 있다.



위에서 고정소수점수끼리 더하거나 뺄 때 그대로 계산하는 특징이 있었는데.

정수 부분과 소수 부분의 길이가 다르면 그 결과값이 올바르지 않게 된다.

따라서 고정소수점수의 형식은 사용자가 원하는 대로 정할 수 있지만, 형식이 서로 다른 고정소수점수를 연산할 때는 주의해야 한다.



### 고정소수점의 특징

#### 장점

- 소수점 아래를 표함한 수를 표현할 수 있음

- 더하기, 빼기가 쉬움

- 표현 범위를 어느 정도 마음대로 바꿀 수 있음

#### 단점

- 다른 형식(표현 범위가 다른 고정소수점)끼리 더하기, 빼기가 어려움

- 곱하기, 나누기가 복잡함(고정소수점수의 형이 따로 없어서)

- 한정된 메모리에서 부동 소수점 방식보다 표현할 수 있는 범위가 제한적

