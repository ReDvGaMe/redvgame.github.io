---

title: "게임수학&물리 001_소수"
date: 2019-03-04 13:44:00 -0400
categories: "게임수학&물리"
comments: true

---

## 소수

**소수(Decimal)**는 각각의 자리에 놓인 숫자와 소수점을 통해 나타낸 실수

소수점 왼쪽에 놓인 숫자들은 실수의 정수 부분, 소수점 오른쪽에 놓인 숫자들은 실수의 소수 부분을 나타낸다.

소수를 표현하는 방법에는 **고정 소수점** 방식과 **부동 소수점** 방식이 있다.

------



## 고정소수점

**고정소수점**은 소수점을 사용하여 고정된 자리수의 소수를 나타내는 것

소수점 위치를 고정시킨 수 표현 방식, 소수점이 항상 같은 위치에 있다.



예를 들어 4바이트 수일 때 1바이트 = 8비트 이므로 32비트 수가 된다.

이 수를 비트로 나타냈을 때 위쪽 16비트를 정수 부분, 아래쪽 16비트를 소수 부분으로 생각할 수 있다.

아래는 1을 나타내는 소수를 4바이트 수로 나타낸 것이다.

```
0001		0000
정수 부분	 소수 부분
```

위와 같이 비트로 구성한 수를 0x10000(65536)으로 나누면 원래 수를 알 수 있다.

고정소수점수는 특정한 '형'을 가지지 않고, 평소에 사용하는 자료형(정수)을 사용해서 고정소수점수를 표현한다.





#### 고정소수점수의 연산

고정소수점수끼리는 더하거나 뺄 때 그대로 계산하는 특징이 있다.

```c
0x00438000 = 정수 부분 : 0x0043(67), 소수 부분 : 0x8000(0.5) -> 67.5
0x00126000 = 정수 부분 : 0x0012(18), 소수 부분 : 0x6000(0.375) -> 18.375

덧셈 : 0x0056e000
뺄셈 : 0x00312000
```

단, 곱하기나 나누기는 위와 같은 방식으로 계산할 수 없다.

67.5에 1.0을 곱하고 나누면 67.5로 바뀐 것이 없어야 하나, 아래의 결과를 보면 다르다는 걸 알 수 있다.

```c
0x00438000 = 정수 부분 : 0x0043(67), 소수 부분 : 0x8000(0.5) -> 67.5
0x00010000 = 정수 부분 : 0x0001(1), 소수 부분 : 0x0000(0.0) -> 1.0

곱하기 : 0x80000000
나누기 : 0x00000043
```

이는 고정소수점수에 특정한 형이 있지 않고 일반적인 정수로 계산하기 때문에

67.5 * 1.0은 4바이트 수에서 (67.5 * 65536) * (1.0 * 65536) 이 되어서 매우 큰 수가 된다고 예측 가능하다.

따라서 고정소수점수를 곱하거나 나눌 땐 다른 방식을 사용해야한다.





#### 고정소수점수의 형식

위의 예제에서는 정수 부분, 소수 부분을 각각 16비트씩 사용하였지만,

고정소수점수에서는 정수와 소수에 몇 비트를 할당하지 자유롭게 설정이 가능하다.

예를들어 4바이트 수에서 정수 부분을 8비트로, 소수 부분을 24비트로 사용하면 

(unsigned라고 가정했을 때) 정수 부분은 8비트인 0 ~ 255의 범위를 소수 부분은 24비트인  0 ~ 16777215을 나타낼 수 있다.



위에서 고정소수점수끼리 더하거나 뺄 때 그대로 계산하는 특징이 있었는데,

정수 부분과 소수 부분의 길이가 다르면 그 결과값이 올바르지 않게 된다.

따라서 고정소수점수의 형식은 사용자가 원하는 대로 정할 수 있지만, 형식이 서로 다른 고정소수점수를 연산할 때는 주의해야 한다.





#### 고정소수점수의 특징

##### 장점

- 소수점 아래를 표함한 수를 표현할 수 있음
- 더하기, 빼기가 쉬움
- 표현 범위를 어느 정도 마음대로 바꿀 수 있음

##### 단점

- 다른 형식(표현 범위가 다른 고정소수점)끼리 더하기, 빼기가 어려움
- 곱하기, 나누기가 복잡함(고정소수점수의 형이 따로 없어서)
- 한정된 메모리에서 부동 소수점 방식보다 표현할 수 있는 범위가 제한적

------



## 부동소수점

**부동소수점**은 실수를 컴퓨터 상에서 근사하여 표현할 때 소수점의 위치를 고정하지 않고 그 위치를 나타내는 수를 따로 적는 것으로, 유효숫자를 나타내는 **가수(假數)**와 소수점의 위치를 풀이하는 **지수(指數)**로 나누어 표현하는 수이다.



부동소수점은 일반적으로 32비트로 구성되어 있는데 이 비트는

**부호 부분**이 1비트, **지수 부분**이 8비트, **가수 부분**이 23비트로 배분되어 있다.



**부호 부분** : 이 부분이 0이면 양수, 1이면 음수가 됨

**지수 부분** : 수 크기의 기준에 되는 정보가 들어감, 지수에 들어가는 수를 결정

**가수 부분** : 지수 부분에 있는 기준 값을 목표 값에 가깝게 하는 정보가 들어감, 최상위 비트가 지수 부분에서 결정한 값의 절반 값, 그 다음 비트에서 또 절반 값으로 비트가 하나씩 내려갈 때마다 계속 반씩 줄여 나가는 방식으로 할당



부동소수점을 프로그램에서 사용할 때는 32비트 부동소수점은 float형, 64비트 부동소수점은 double형을 사용하면 된다.(double형은 부호, 지수, 가수 순으로 1, 11, 52비트가 할당되어 있다.)



컴퓨터에서는 고정 소수점 방식보다 넓은 범위의 수를 나타낼 수 있어 많이 이용되지만, 근삿값으로 표현되며 고정 소수점 방식보다 연산 속도가 느리기 때문에 별도의 전용 연산 장치를 두는 경우가 많은데 이를 **FPU(Floating Point Unit)** 이라고 한다.



#### 부동소수점수의 오차

-  유효 숫자 누락

  서로 가까운 두 값끼리 뺀 결과가 양수이면서 1보다 작을 때 비트 수준에서 유효 숫자가 적어지는 것

-  정보 누락

  계산에 사용하는 두 값 중 하나가 매우 크고 나머지 하나는 매우 작을 때 작은 값의 의미가 사라지는 오차



#### 부동소수점수의 특징

##### 장점

- 소수점 아래를 표함한 수를 표현할 수 있음
- 고정소수점수보다 정밀도가 높음
- 연산을 자유롭게 할 수 있음

##### 단점

- 예외가 발생할 가능성이 있음
- 상황에 따라 계산 오차가 발생할 수 있음



------

> 본 내용은 도마에 요시키의 "게임을 움직이는 수학과 물리"를 읽으며 공부, 요약한 내용입니다.
